# === Consult On Project Rules (Advanced) ===
include:
  - apps/**
  - packages/**
  - infra/**
exclude:
  - node_modules/**
  - dist/**
  - .next/**
  - coverage/**

rules:
  # ---------- 프론트엔드 ----------
  - Next.js는 App Router만 사용한다 (Pages Router 금지)
  - Next.js API Routes는 사용하지 않는다 (백엔드는 NestJS로만)
  - UI 스타일은 Tailwind만 사용한다 (Bootstrap/Material 등 금지)
  - 서버 상태는 TanStack Query, 전역 UI 상태는 Zustand로 관리한다
  - HTTP 통신은 Axios 인스턴스만 사용한다 (fetch 직접 호출 금지)
  - 환경변수는 NEXT_PUBLIC_ 접두어만 FE에서 접근한다
  - 대용량/미디어 업로드 UI는 S3 Pre-signed URL 기반으로 구현한다 (직접 BE로 바이너리 전송 금지)
  - 업로드 진행률/취소/재시도를 지원하고, 5xx/네트워크 에러 시 지수적 백오프로 재시도한다

  # ---------- 백엔드 ----------
  - ORM은 Prisma만 사용한다 (Sequelize/TypeORM 금지)
  - 모듈 식(NestJS) 구조를 유지한다: auth, users, experts, reservations, sessions, payments, credits, ai, files, admin, health, agora
  - 모든 HTTP API는 '/v1' 프리픽스로 노출한다 (버전 관리)
  - DTO/입력 검증은 Zod를 사용한다 (class-validator 금지)
  - 환경변수는 @nestjs/config + Zod로 부트 시 검증한다 (누락 시 기동 실패)
  - DB 변경은 Prisma migrate만 사용한다 (수동 DDL 금지)
  - 메시지 큐/잡 처리는 BullMQ만 사용한다
  - 로깅은 JSON(레벨, 타임스탬프, 요청ID, 경로)으로 남긴다. PII는 마스킹한다
  - OpenTelemetry/Sentry 연동 훅을 남겨둔다 (추가 시 주석 제거)
  - CORS는 화이트리스트 도메인만 허용하고 Helmet 보안 헤더를 사용한다
  - 외부 API 키(OpenAI/Toss/Agora 등)는 FE에 노출 금지, 항상 백엔드 프록시 경유

  # ---------- 응답/에러 표준화 ----------
  - 모든 응답은 `{ success:boolean, data?:T, error?:{ code:string, message:string, details?:any } }` 포맷을 따른다
  - 상태코드 표준:
    # 2xx
    - 200 OK : 조회/일반 성공
    - 201 Created : 생성 성공
    - 202 Accepted : 비동기 처리 수락(Job 큐에 적재)
    - 204 No Content : 삭제/토글 등 본문 없음
    # 4xx
    - 400 Bad Request : 유효성 실패(Zod) 또는 잘못된 파라미터
    - 401 Unauthorized : 인증 필요/토큰 만료
    - 403 Forbidden : 권한 없음(RBAC)
    - 404 Not Found : 리소스 없음
    - 409 Conflict : 중복/경합(예약중복, idempotency 충돌)
    - 422 Unprocessable Entity : 의미적 유효성 실패(도메인 규칙 위반)
    - 429 Too Many Requests : 레이트 리밋
    # 5xx
    - 500 Internal Server Error : 서버 내부 오류
    - 503 Service Unavailable : 종속 서비스 다운/타임아웃
  - 에러코드 네이밍: E_AUTH_*, E_PAY_*, E_RES_*, E_AI_*, E_FILE_*, E_DB_*, E_RATE_*
  - 에러 응답 예시:
    # { "success": false, "error": { "code": "E_RES_CONFLICT", "message": "Time slot already reserved", "details": { "expertId": 1, "startAt": "..." } } }

  # ---------- 인증/인가 ----------
  - 인증은 JWT Access(15m) + Refresh(14d) 로테이션을 사용한다
  - 토큰은 httpOnly+Secure 쿠키로 저장한다 (localStorage 금지)
  - Refresh 토큰은 jti(고유ID) 기반으로 로테이션하며, 서버측(REDIS)에 화이트리스트(또는 세션 레코드)로 관리한다
  - 비밀번호 해시는 Argon2를 사용한다 (bcrypt 금지)
  - 이메일 인증/비번 재설정 토큰은 15~30분 만료, 1회용, 서버 저장소에 해시로 저장한다
  - RBAC 역할: USER/EXPERT/ADMIN. 라우트는 RoleGuard로 보호한다
  - 레이트리밋: 로그인/회원가입/AI 프록시/결제는 IP 또는 userId 기준으로 제한한다
  - CSRF: 쿠키 기반 인증 경로에 대해 CSRF 토큰(더블 서브밋 또는 SameSite=strict)을 적용한다

  # ---------- 파일 저장 인프라 ----------
  - 파일 저장은 AWS S3를 사용한다. 버킷은 환경별 분리(stg/prod)
  - S3는 서버측 암호화(SSE-S3 또는 SSE-KMS)를 적용한다
  - 공개/비공개 경로를 prefix로 분리한다 (e.g., public/avatars, private/records)
  - CloudFront를 통해 정적/공개 자산을 캐싱한다. 비공개 객체는 서명 URL로 접근한다
  - 수명주기 정책: 원본 보관 기간/아카이브/삭제를 정책으로 정의한다 (e.g., tmp/* 7일)
  - 파일명 충돌 방지: 외부노출ID(ULID) + 확장자, 디렉토리 구조는 userId/날짜 기반으로 정규화

  # ---------- 파일 업로드(서버/클라이언트) ----------
  - 업로드는 항상 "백엔드가 발급한 Pre-signed URL"로 S3에 직접 PUT/POST한다 (BE로 바이너리 전송 금지)
  - 대용량 업로드는 S3 멀티파트 업로드를 사용한다 (5MB~5GB)
  - 허용 MIME/확장자 화이트리스트를 적용한다 (예: 이미지: jpg/png/webp; 문서: pdf; 영상: mp4 등)
  - 파일 크기 상한을 설정한다 (예: 이미지 ≤ 10MB, 영상 ≤ 200MB — 실제 요구에 맞게 조정)
  - 바이러스 스캔(선택): 업로드 완료 이벤트로 Lambda(ClamAV) 트리거하여 private → safe/로 이동
  - 썸네일/트랜스코딩(선택): 이미지 리사이즈/LQIP, 영상은 MediaConvert 파이프라인으로 HLS 생성
  - BE는 pre-signed 발급 시 다음을 검증한다: 인증/권한, 파일 크기, MIME, 경로 prefix, 만료시간(60~300s)
  - 업로드 감사로그를 남긴다: actorId, filename, size, mime, ip, userAgent, objectKey

  # ---------- 클라이언트 멀티미디어 처리 ----------
  - 미디어 캡처/선택은 브라우저 Media APIs를 사용한다 (권한 프롬프트/오류 처리 포함)
  - 업로드는 진행률 표시/취소/재시도(지수 백오프)를 지원한다
  - 영상은 모바일 네트워크에서 업로드 전 길이/해상도/용량 경고를 띄운다
  - 업로드 성공 후 캐시 무효화/목록 갱신을 수행한다 (TanStack Query invalidate)

  # ---------- API 오류 테스트(필수) ----------
  - 단위 테스트(Jest): 각 서비스/유스케이스의 실패 경로(유효성 실패, 404, 409, 401/403, 429)를 포함한다
  - 통합 테스트(Jest e2e 또는 Supertest): 대표 엔드포인트의 정상/이상(잘못된 바디, 누락된 헤더, 만료 토큰)을 검증한다
  - E2E(Playwright): 주요 사용자 플로우(로그인, 목록 조회, 예약 생성/취소, 업로드)에서 실패 케이스(네트워크 차단/5xx 모킹/429)를 검증한다
  - 카나리/CHAOS(선택): 외부 의존(결제/AI) 실패 모킹 시 서비스가 502/503과 표준 에러바디를 반환하는지 확인한다
  - 테스트 데이터는 Prisma 테스트 DB를 사용하며, 각 테스트 전후 트랜잭션 롤백이나 DB 리셋을 수행한다

  # ---------- Idempotency & 결제/예약 ----------
  - 결제/예약/중복 위험이 있는 POST는 Idempotency-Key 헤더를 지원한다
  - Webhook은 provider+ref로 UNIQUE 제약을 두고 반드시 멱등하게 처리한다
  - 예약은 `@@unique([expertId, startAt])`로 중복 방지한다

  # ---------- ID/소프트 삭제/표면 정책 ----------
  - 내부 PK는 bigint autoincrement, 외부 노출용 ID는 ULID(또는 cuid2)로 생성해 응답한다
  - 기본 삭제는 소프트 삭제(deletedAt). 하드 삭제는 승인된 마이그레이션/운영 스크립트에서만
  - 리스트 API는 기본적으로 deletedAt=null 조건을 자동으로 적용한다

  # ---------- 상태 페이지/헬스체크 ----------
  - `/v1/health`는 서버 상태, DB ping, Redis ping을 포함한다
  - 헬스 실패 시 503 반환, 에러 바디는 표준화된 포맷을 따른다

  # ---------- Git/품질 ----------
  - Conventional Commits를 따른다 (feat:, fix:, chore:, refactor:, test:)
  - Husky + lint-staged + commitlint를 설정하고, 커밋 전에 lint/typecheck/test를 통과해야 한다
  - OpenAPI(Swagger) 문서를 /v1/docs 경로에 노출한다 (보안: 로컬/스테이징만, 프로덕션은 보호)
