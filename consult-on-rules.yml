# === Consult On Project Rules (Advanced) ===
include:
  - apps/**
  - packages/**
  - infra/**
exclude:
  - node_modules/**
  - dist/**
  - .next/**
  - coverage/**

rules:
  # ---------- 프론트엔드 ----------
  - Next.js는 App Router만 사용한다 (Pages Router 금지)
  - Next.js API Routes는 사용하지 않는다 (백엔드는 NestJS로만)
  - UI 스타일은 Tailwind만 사용한다 (Bootstrap/Material 등 금지)
  - 서버 상태는 TanStack Query, 전역 UI 상태는 Zustand로 관리한다
  - HTTP 통신은 Axios 인스턴스만 사용한다 (fetch 직접 호출 금지)
  - 환경변수는 NEXT_PUBLIC_ 접두어만 FE에서 접근한다
  - 대용량/미디어 업로드 UI는 S3 Pre-signed URL 기반으로 구현한다 (직접 BE로 바이너리 전송 금지)
  - 업로드 진행률/취소/재시도를 지원하고, 5xx/네트워크 에러 시 지수적 백오프로 재시도한다

  # ---------- 백엔드 ----------
  - ORM은 Prisma만 사용한다 (Sequelize/TypeORM 금지)
  - 모듈 식(NestJS) 구조를 유지한다: auth, users, experts, reservations, sessions, payments, credits, ai, files, admin, health, agora
  - 모든 HTTP API는 '/v1' 프리픽스로 노출한다 (버전 관리)
  - DTO/입력 검증은 Zod를 사용한다 (class-validator 금지)
  - 환경변수는 @nestjs/config + Zod로 부트 시 검증한다 (누락 시 기동 실패)
  - DB 변경은 Prisma migrate만 사용한다 (수동 DDL 금지)
  - 메시지 큐/잡 처리는 BullMQ만 사용한다
  - 로깅은 JSON(레벨, 타임스탬프, 요청ID, 경로)으로 남긴다. PII는 마스킹한다
  - OpenTelemetry/Sentry 연동 훅을 남겨둔다 (추가 시 주석 제거)
  - CORS는 화이트리스트 도메인만 허용하고 Helmet 보안 헤더를 사용한다
  - 외부 API 키(OpenAI/Toss/Agora 등)는 FE에 노출 금지, 항상 백엔드 프록시 경유

  # ---------- 응답/에러 표준화 ----------
  - 모든 응답은 `{ success:boolean, data?:T, error?:{ code:string, message:string, details?:any } }` 포맷을 따른다
  - 상태코드 표준:
    # 2xx
    - 200 OK : 조회/일반 성공
    - 201 Created : 생성 성공
    - 202 Accepted : 비동기 처리 수락(Job 큐에 적재)
    - 204 No Content : 삭제/토글 등 본문 없음
    # 4xx
    - 400 Bad Request : 유효성 실패(Zod) 또는 잘못된 파라미터
    - 401 Unauthorized : 인증 필요/토큰 만료
    - 403 Forbidden : 권한 없음(RBAC)
    - 404 Not Found : 리소스 없음
    - 409 Conflict : 중복/경합(예약중복, idempotency 충돌)
    - 422 Unprocessable Entity : 의미적 유효성 실패(도메인 규칙 위반)
    - 429 Too Many Requests : 레이트 리밋
    # 5xx
    - 500 Internal Server Error : 서버 내부 오류
    - 503 Service Unavailable : 종속 서비스 다운/타임아웃
  - 에러코드 네이밍: E_AUTH_*, E_PAY_*, E_RES_*, E_AI_*, E_FILE_*, E_DB_*, E_RATE_*
  - 에러 응답 예시:
    # { "success": false, "error": { "code": "E_RES_CONFLICT", "message": "Time slot already reserved", "details": { "expertId": 1, "startAt": "..." } } }

  # ---------- 인증/인가 ----------
  - 인증은 JWT Access(2h) + Refresh(14d) 로테이션을 사용한다 (상담 세션 최대 1.5시간 고려)
  - 토큰은 httpOnly+Secure 쿠키로 저장한다 (localStorage 금지)
  - Refresh 토큰은 jti(고유ID) 기반으로 로테이션하며, 서버측(REDIS)에 화이트리스트(또는 세션 레코드)로 관리한다
  - 비밀번호 해시는 Argon2를 사용한다 (bcrypt 금지)
  - 이메일 인증/비번 재설정 토큰은 15~30분 만료, 1회용, 서버 저장소에 해시로 저장한다
  - RBAC 역할: USER/EXPERT/ADMIN. 라우트는 RoleGuard로 보호한다
  - 레이트리밋: 로그인/회원가입/AI 프록시/결제는 IP 또는 userId 기준으로 제한한다
  - CSRF: 쿠키 기반 인증 경로에 대해 CSRF 토큰(더블 서브밋 또는 SameSite=strict)을 적용한다

  # ---------- 파일 저장 인프라 ----------
  - 파일 저장은 AWS S3를 사용한다. 버킷은 환경별 분리(stg/prod)
  - S3는 서버측 암호화(SSE-S3 또는 SSE-KMS)를 적용한다
  - 공개/비공개 경로를 prefix로 분리한다 (e.g., public/avatars, private/records)
  - CloudFront를 통해 정적/공개 자산을 캐싱한다. 비공개 객체는 서명 URL로 접근한다
  - 수명주기 정책: 원본 보관 기간/아카이브/삭제를 정책으로 정의한다 (e.g., tmp/* 7일)
  - 파일명 충돌 방지: 외부노출ID(ULID) + 확장자, 디렉토리 구조는 userId/날짜 기반으로 정규화

  # ---------- 파일 업로드(서버/클라이언트) ----------
  - 업로드는 항상 "백엔드가 발급한 Pre-signed URL"로 S3에 직접 PUT/POST한다 (BE로 바이너리 전송 금지)
  - 대용량 업로드는 S3 멀티파트 업로드를 사용한다 (5MB~5GB)
  - 허용 MIME/확장자 화이트리스트를 적용한다 (예: 이미지: jpg/png/webp; 문서: pdf; 영상: mp4 등)
  - 파일 크기 상한을 설정한다 (예: 이미지 ≤ 10MB, 영상 ≤ 200MB — 실제 요구에 맞게 조정)
  - 바이러스 스캔(선택): 업로드 완료 이벤트로 Lambda(ClamAV) 트리거하여 private → safe/로 이동
  - 썸네일/트랜스코딩(선택): 이미지 리사이즈/LQIP, 영상은 MediaConvert 파이프라인으로 HLS 생성
  - BE는 pre-signed 발급 시 다음을 검증한다: 인증/권한, 파일 크기, MIME, 경로 prefix, 만료시간(60~300s)
  - 업로드 감사로그를 남긴다: actorId, filename, size, mime, ip, userAgent, objectKey

  # ---------- 클라이언트 멀티미디어 처리 ----------
  - 미디어 캡처/선택은 브라우저 Media APIs를 사용한다 (권한 프롬프트/오류 처리 포함)
  - 업로드는 진행률 표시/취소/재시도(지수 백오프)를 지원한다
  - 영상은 모바일 네트워크에서 업로드 전 길이/해상도/용량 경고를 띄운다
  - 업로드 성공 후 캐시 무효화/목록 갱신을 수행한다 (TanStack Query invalidate)

  # ---------- API 오류 테스트(필수) ----------
  - 단위 테스트(Jest): 각 서비스/유스케이스의 실패 경로(유효성 실패, 404, 409, 401/403, 429)를 포함한다
  - 통합 테스트(Jest e2e 또는 Supertest): 대표 엔드포인트의 정상/이상(잘못된 바디, 누락된 헤더, 만료 토큰)을 검증한다
  - E2E(Playwright): 주요 사용자 플로우(로그인, 목록 조회, 예약 생성/취소, 업로드)에서 실패 케이스(네트워크 차단/5xx 모킹/429)를 검증한다
  - 카나리/CHAOS(선택): 외부 의존(결제/AI) 실패 모킹 시 서비스가 502/503과 표준 에러바디를 반환하는지 확인한다
  - 테스트 데이터는 Prisma 테스트 DB를 사용하며, 각 테스트 전후 트랜잭션 롤백이나 DB 리셋을 수행한다

  # ---------- Idempotency & 결제/예약 ----------
  - 결제/예약/중복 위험이 있는 POST는 Idempotency-Key 헤더를 지원한다
  - Webhook은 provider+ref로 UNIQUE 제약을 두고 반드시 멱등하게 처리한다
  - 예약은 `@@unique([expertId, startAt])`로 중복 방지한다

  # ---------- ID/소프트 삭제/표면 정책 ----------
  - 내부 PK는 bigint autoincrement, 외부 노출용 ID는 ULID(또는 cuid2)로 생성해 응답한다
  - 기본 삭제는 소프트 삭제(deletedAt). 하드 삭제는 승인된 마이그레이션/운영 스크립트에서만
  - 리스트 API는 기본적으로 deletedAt=null 조건을 자동으로 적용한다

  # ---------- 상태 페이지/헬스체크 ----------
  - `/v1/health`는 서버 상태, DB ping, Redis ping을 포함한다
  - 헬스 실패 시 503 반환, 에러 바디는 표준화된 포맷을 따른다

  # ---------- Git/품질 ----------
  - Conventional Commits를 따른다 (feat:, fix:, chore:, refactor:, test:)
  - Husky + lint-staged + commitlint를 설정하고, 커밋 전에 lint/typecheck/test를 통과해야 한다
  - OpenAPI(Swagger) 문서를 /v1/docs 경로에 노출한다 (보안: 로컬/스테이징만, 프로덕션은 보호)

  # ---------- 성능 최적화 ----------
  - 프론트엔드 번들은 Webpack Bundle Analyzer로 정기 분석하고, 불필요한 dependency를 제거한다
  - 이미지는 Next.js Image 컴포넌트로 최적화하고, WebP/AVIF 포맷을 우선 사용한다
  - 폰트는 Google Fonts 최적화 또는 self-host로 FOUT/FOIT를 방지한다
  - Critical CSS를 인라인하고, non-critical CSS는 비동기 로드한다
  - API 응답에는 적절한 캐시 헤더(Cache-Control, ETag)를 설정한다
  - DB 쿼리는 N+1 문제를 방지하고, 인덱스 최적화를 정기 점검한다
  - Redis 캐싱 전략: 자주 조회되는 전문가 목록, 카테고리, 사용자 세션은 TTL 기반 캐싱
  - CDN을 통해 정적 자산과 API 응답(적절한 경우)을 엣지에서 캐싱한다

  # ---------- 모니터링 & 관찰성 ----------
  - 프로덕션 환경에서는 반드시 구조화된 로깅(JSON)과 분산 추적을 활성화한다
  - 핵심 비즈니스 메트릭을 추적한다: 예약 성공률, 결제 완료율, 세션 연결 성공률, 사용자 만족도
  - SLI/SLO를 정의한다: API 응답시간 P95 < 500ms, 가용성 > 99.9%, 오류율 < 0.1%
  - APM 도구(DataDog/New Relic)를 연동하여 성능 병목과 오류를 실시간 모니터링한다
  - 알림 규칙: 5xx 오류 급증, DB 연결 실패, 결제 실패율 증가, 메모리/CPU 임계치 초과
  - 헬스체크는 얕은/깊은 수준으로 분리: `/health` (기본), `/health/deep` (DB/Redis/외부 서비스 포함)
  - 로그에는 추적 가능한 requestId, userId, sessionId를 포함하고, 민감정보(PII)는 마스킹한다

  # ---------- 보안 강화 ----------
  - API 엔드포인트에는 입력 크기 제한을 설정한다 (JSON body ≤ 1MB, 쿼리 파라미터 ≤ 4KB)
  - SQL Injection 방지: Prisma의 타입세이프 쿼리만 사용하고, raw query는 금지한다
  - XSS 방지: 사용자 입력은 항상 sanitize하고, CSP 헤더를 설정한다
  - SSRF 방지: 외부 URL 호출 시 화이트리스트 도메인만 허용한다
  - 민감한 환경변수는 AWS Secrets Manager/HashiCorp Vault로 관리한다
  - API 키 로테이션: 외부 서비스 API 키는 정기적으로 순환하고, 키 만료 알림을 설정한다
  - 보안 헤더: X-Frame-Options, X-Content-Type-Options, Referrer-Policy를 설정한다
  - 취약점 스캔: 정기적으로 npm audit, Snyk, OWASP ZAP을 실행한다

  # ---------- 실시간 기능 (WebRTC/WebSocket) ----------
  - Agora SDK는 최신 버전을 유지하고, connection state 변화를 적절히 핸들링한다
  - WebRTC 연결 실패 시 fallback 메커니즘(음성 → 채팅)을 제공한다
  - 네트워크 품질 모니터링: 대역폭, 패킷 손실, 지연시간을 실시간 추적한다
  - 세션 중 예상치 못한 연결 해제 시 자동 재연결을 시도한다 (최대 3회, 지수 백오프)
  - 실시간 상태는 Redis Pub/Sub으로 다중 서버 간 동기화한다
  - WebSocket은 heartbeat/ping-pong으로 연결 상태를 확인하고, 좀비 연결을 정리한다

  # ---------- 데이터 일관성 & 트랜잭션 ----------
  - 중요한 비즈니스 로직(결제, 예약)은 DB 트랜잭션으로 원자성을 보장한다
  - 분산 트랜잭션이 필요한 경우 Saga 패턴 또는 2PC를 적용한다
  - 동시성 제어: 예약 충돌은 낙관적 잠금(version field) 또는 Redis 분산 락을 사용한다
  - 데이터 정합성 검증: 정기적으로 배치 작업으로 데이터 무결성을 검사한다
  - 크리티컬 데이터는 정기 백업하고, 복구 절차를 문서화한다
  - 감사 로그: 중요한 데이터 변경(결제, 예약, 권한 변경)은 별도 테이블에 기록한다

  # ---------- 접근성 & UX ----------
  - WCAG 2.1 AA 수준을 준수한다: 키보드 내비게이션, 스크린 리더 지원, 색상 대비
  - 모든 interactive 요소는 적절한 ARIA 속성을 가져야 한다
  - 폼 검증은 실시간 피드백과 명확한 오류 메시지를 제공한다
  - 로딩 상태는 스켈레톤 UI 또는 프로그레스 인디케이터로 표시한다
  - 오프라인 시나리오를 고려하고, 네트워크 오류 시 적절한 fallback UI를 제공한다
  - 다국어 지원 준비: i18n 구조를 미리 설계하고, 하드코딩된 텍스트를 방지한다

  # ---------- DevOps & 배포 ----------
  - Infrastructure as Code(IaC): Terraform 또는 AWS CDK로 인프라를 코드화한다
  - 컨테이너화: 멀티스테이지 Docker 빌드로 최적화된 프로덕션 이미지를 생성한다
  - CI/CD 파이프라인: 테스트 → 빌드 → 보안 스캔 → 배포 순서로 자동화한다
  - Blue-Green 또는 Canary 배포로 무중단 배포를 구현한다
  - 환경별 설정 분리: local/staging/production 환경변수와 시크릿을 격리한다
  - 롤백 계획: 배포 실패 시 즉시 이전 버전으로 복구할 수 있는 절차를 준비한다
  - 데이터베이스 마이그레이션은 하위 호환성을 유지하고, 다운타임을 최소화한다

  # ---------- 비즈니스 로직 검증 ----------
  - 도메인 규칙은 서비스 레이어에 캡슐화하고, 컨트롤러는 얇게 유지한다
  - 비즈니스 로직 단위 테스트 커버리지는 최소 80%를 유지한다
  - Edge case 처리: 타임존 차이, 휴일/주말, 동시 예약, 결제 실패 등을 고려한다
  - 사용자 권한 검증은 모든 API 엔드포인트에서 일관되게 적용한다
  - 데이터 검증은 클라이언트와 서버 양쪽에서 수행하되, 서버 검증을 신뢰한다

  # ---------- 코드 품질 & 아키텍처 ----------
  - 순환 의존성을 방지하고, 의존성 그래프는 단방향으로 유지한다
  - 공통 로직은 유틸리티/서비스로 추출하여 중복을 제거한다
  - 매직 넘버/문자열은 상수로 정의하고, 의미있는 이름을 사용한다
  - 함수는 단일 책임 원칙을 따르고, 복잡한 로직은 작은 함수로 분해한다
  - TypeScript strict 모드를 활성화하고, any 타입 사용을 최소화한다
  - 코드 리뷰 체크리스트: 성능 영향, 보안 취약점, 테스트 커버리지, 문서화
  - 기술 부채는 별도 이슈로 추적하고, 정기적으로 리팩토링 시간을 확보한다
